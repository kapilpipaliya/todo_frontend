LET k = (FOR t IN @@insCollection
    FILTER t._key == "2698836" 
    UPDATE t WITH @insData IN  @@insCollection
    RETURN NEW._key)
    
    
    // find all existing group_member
    // delete that is not in new data
    // update that is existing
    // insert that is new
    
    //LET deleted_g = (FOR k_ in k 
    LET k_ = FIRST(k)
        // find existing member keys
        LET exiting_group_member = (for e in group_member
            FILTER e._from == k_
            RETURN e._to)
            
        LET deleted_group_member = MINUS(exiting_group_member, @group_member)
        LET update_group_member = INTERSECTION(exiting_group_member, @group_member)
        LET new_group_member = MINUS(@group_member, update_group_member)
    
        // update
        // for pure join no update!
        //FOR n in update_group_member
            //UPDATE WITH @insData IN  @@insCollection
    
        // insert
        LET x2 = (FOR n_i in new_group_member
            INSERT {_from: CONCAT("group/", k_), _to: CONCAT("member/", n_i)} INTO group_member)

        //RETURN deleted_group_member
    //)
    // delete if key not exist in new data key array
    //LET x1 = (FOR d in FIRST(deleted_group_member)
        //REMOVE CONCAT("group_member/", d) IN group_member )
    
RETURN k


Final update query:
LET k = (FOR t IN @@insCollection
    //FILTER t._key == "2732849" 
    UPDATE t WITH @insData IN  @@insCollection
    RETURN NEW._key)

    LET deleted_g = (FOR k_ in k 
        LET exiting_group_member = (for e in group_member
            FILTER e._from == CONCAT("group/", k_)
            RETURN e)

        LET deleted_member = MINUS(exiting_group_member[*]._to, @member)
        //LET update_group_member = INTERSECTION(exiting_group_member[*]._to, @group_member)
        //LET new_group_member = MINUS(@member, update_group_member)
        LET new_update_member = MINUS(@member, deleted_member)
        LET deleted_group_member = (FOR e in exiting_group_member
            FILTER  !POSITION( @member, SPLIT(e._to, "/")[1] )
            RETURN SPLIT(e._to, "/")[1]
        )

        // update
        // for pure join no update!
        // FOR n in update_group_member
            //UPDATE WITH @insData IN  @@insCollection
    
        // insert
        // LET x2 = (FOR n_i in new_group_member
            //INSERT {_from: CONCAT("group/", k_), _to: CONCAT("member/", n_i)} INTO group_member)
            
        // upsert
        LET u = (FOR n in new_update_member
            UPSERT {_from: CONCAT("group/", k_), _to: CONCAT("member/", n)}
                INSERT {_from: CONCAT("group/", k_), _to: CONCAT("member/", n)}
                UPDATE {}
                IN group_member
        )

        RETURN deleted_group_member
    )
    // delete if key not exist in new data key array
    // cant do this:
    // LET x1 = (FOR d in deleted_g
        //REMOVE CONCAT("group_member/", d) IN group_member )
    
RETURN [k, FLATTEN(deleted_g)]
